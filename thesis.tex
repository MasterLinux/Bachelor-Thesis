\documentclass[fontsize=12pt,a4paper]{scrartcl}[2003/01/01]

\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}

\title{Design of an UML tool with round-trip engineering for Java and implementation as a web application in Adobe Air}
\date{10.08.2011}
\author{Christoph Grundmann}

\begin{document}
\maketitle 
\tableofcontents 

\section{User Interface (UI)}

\subsection{UI Object}
Each UI element, like a tab or the file tree, inherits from a base class called ui.Object. This class provides the managing of event listener, the creation of a unique id or handles the deletion of the UI element. Furthermore it implies some useful utilities, like hiding or showing the UI element. But one of the most important features is the event manager. So it's necessary to unset each event listener, which listen to a removed DOM node. In addition the event manager provides the registration of new event listener for specific events and can deactivate, activate or remove each listener by name. Furthermore it's possible to activate or deactivate all listeners at the same time, what's necessary if a UI object will be destroyed. The “activate” and “deactivate” function can be overwritten to extend the functionality, by example to destroy the DOM node at deactivating. Another important feature is the generation of a unique id for the DOM node of the UI element. So the HTML standard defines that an id has to use once only. If two nodes have the same id, the JavaScript engine of the web-browser can't get access to both. To get a unique id the id-creator uses the class name as base and searches for other nodes of that class, counts each appearance and appends the counter to the class name. The last mentionable function of the base class is the deletion handling. To be sure that each registered event listener and each used UI element of an UI element, like a button of a dialog, including the DOM node will be destroyed, the base class has a specific destroy function, which handles the "garbage collection". To initialize an UI object a function called "create" will be used. It generates a unique id, places the DOM node and sets up all necessary event listeners. A UI object has a specific uitype, which will be used to identify a DOM node as a UI element. It will be set as a HTML attribute and can be accessed on a catch event.

\subsection{The basics of the GUI design}
On the top of the GUI the window object manages the resizing and the full-screen mode of the Adobe Air window. Furthermore it contains some frames, which will be placed and resized with the help of the current window properties. A frame is the main actor in handling tabs and its content. It resizes the tab content, like the Java editor or the file tree, and allows opening new tabs. In addition it allows the replacing of tabs. If a user dragged a tab in another frame, the tab will be removed from the old frame and replaced into the new one. In this case only the DOM nodes will be destroyed, but the Meta data - like the source code of a specific editor tab - because it’s necessary to be able to recreate the tab. Furthermore it handles resize events, like rescaling and the full-screen mode of the Adobe Air window. A frame implies the tab-, context menu- and content-management. In addition it allows the replacing of tabs, so a tab can be dragged into another frame. If a tab will be replaced the context menu and the content, like an editor, which are connected to the tab, have to destroy and replace. On replacing each Meta info must be saved, so the old state can be rebuild. A tab is subdivided into 3 parts. At first the tab themselves, which handles the create- and destroy-process of its content and its context menu. In addition it starts its replacing, if a user begins to drag the tab. The next part of a tab is its context menu. The context menu holds a collection of buttons, which can be used to execute specific functions of a tab. For example the editor tab has buttons to save its current document or to resize the font size. The last part is the content object. It provides the access of some tools, like the class diagram editor, a Java editor or a file tree.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/gui_design.png}
\end{figure}

\section{Round-trip engineering}
Today's complexity of software requires the use of diagrams that will describe the structure of programs and how the internal processes communicate, during and primary at the beginning of the development. Moreover for object oriented languages like Java, the UML standard is the way to go, because of its focus for the object oriented developing of software.  
Structure diagrams, like the class diagram, have the capability to generate source code by analyzing it. In addition it's possible to create a class diagram with the help of source code. 
The creation of Java source code from a class diagram is called forward engineering, whereas the creation of a class diagram from the Java source code is called reverse engineering. The whole technique is known as round trip engineering. So round trip engineering allows keeping the consistency between diagrams and source code.

\subsection{Reverse engineering}
To generate a class diagram with the help of Java source code, a parser is needed to interpret the grammatical structure of it. Usually a program doesn’t understand the grammatical structure of an input like a string before it is interpreted. The first step in interpreting the source code a parser converts it into a specific data format, in this case into a JSON object, which can use to interpret the grammatical structure. After that step the new output can be used to generate the class diagram. Classes can easily instantiate by reading the JavaScript friendly output, where the relations need to be interpreted.

\subsubsection{Parser}
AlphaUML uses “PEG.js”, a Java parser that is completely written in JavaScript, to parse Java source code into a JSON object. It allows converting a string, by using a specific language grammar, into any output format. The grammar describes the Java language and defines the output. It follows specific rules similar to regular expressions to match the input with the Java grammar. 
Furthermore it allows manipulating the output of each expression by using JavaScript as a so called “action”. In this case an action is used to convert the expression result to a JSON object. But in some cases an empty string returns if an expression is optional and it doesn’t match. Then the empty string will be replaced with null to catch missing matches in the processing to a class diagram.

\subsubsection{Parser grammar rules}
PEG.js provides some rules which are necessary to write an own grammar. A collection of the most common rules will be described below. In addition a small grammar example with explanation after the rules shows how they are used.

\paragraph*{\textbf{"literal" or 'literal'}}$\;$ \\
Return the literal string on matching.

\paragraph*{\textbf{.}}$\;$ \\
Return one character as a string.

\paragraph*{\textbf{\lbrack characters\rbrack}}$\;$ \\
Return one character of the bracket contained set.

\paragraph*{\textbf{rule}}$\;$ \\
It describes a fully expression that can use in other rules or expressions

\paragraph*{\textbf{(expression)}}$\;$ \\
It allows the declaration of a subexpression to encapsulate it. It’s similar to a rule and is necessary to set an expression optional.

\paragraph*{\textbf{expression *}}$\;$ \\
Zero or more match results allowed. Returns the result as an array.

\paragraph*{\textbf{expression +}}$\;$ \\
One or more match results necessary. If the input doesn't match it returns a parsing error.

\paragraph*{\textbf{expression ?}}$\;$ \\
It allows optional expressions. On succeeding the match result returns, otherwise it returns an empty string.

\paragraph*{\textbf{! expression}}$\;$ \\
It forbids a specific expression.

\paragraph*{\textbf{label : expression}}$\;$ \\
A label stores the match result into a specific variable that has the same name. It can be used in an action to get access of the stored result.

\paragraph*{\textbf{expression \{ action \}}}$\;$ \\
An action is a JavaScript snippet that will be executed 'cause the match is successful. It has the access to each labeled expression of its expression and allows the manipulation of the match result.

\paragraph*{\textbf{expression\_1 expression\_2 \dots expression\_n}}$\;$ \\
A sequence of expression is allowed and returns their results as an array.

\paragraph*{\textbf{expression\_1 / expression\_2 / \dots / expression\_n}}$\;$ \\
It allows to create an OR function. It tries to match with one of the given expressions.

\subsubsection{Parser grammar example}
The following example shows a rule called DataType which is used for parsing a data type. It matches primitive data types, generic types or array types. Each information will return as a JSON object, formatted by the action. The DataTypeKeyword rule provides a collection of data types and allows each possible java identifier (Identifier) as data type, so user-defined objects are possible. The Generic and Array rules are optional and return an empty string on miss.

\lstset{
	language=HTML, 
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1
}

\begin{lstlisting}[caption={list of data type keywords}, frame=single]
DataTypeKeyword = (
        "boolean"
	/   "byte"
	/   "char"
	/   "double"
	/   "enum"
	/   "float"
	/   "int"
	/   "long"
	/   "short"
	/   "void"
	/   Identifier
)
\end{lstlisting}

\begin{lstlisting}[caption={data type rule}, frame=single]
DataType =
    $d:DataTypeKeyword __
    $g:($g:Generic __ {return $g;})?
    $a:($a:Array __ {return $a;})?
    {
        return {
            generic: $g !== "" ? $g : null,
            array: $a !== "" ? $a : false,
            dataType: $d
        };
    }
\end{lstlisting}

\subsubsection{Parser output}
\label{json} 
The produced output from the source code will be used to generate the class diagram. The JSON format of the output makes the next process easier, so it represents a specific logical structure and allows the immediate access to all necessary information about the parsed Java program.
The output provides, for example, the info about used libraries, the class package, all class methods or variables to generate the class diagram. In addition the JavaDoc is available and will be pinned as note at the specific class in the diagram.
The following JSON sample gives an overview about the output format and shows each possible fields like the “package” or “classes” fields.

\begin{lstlisting}[caption={file output}, frame=single]
{
   "package": "packageName",
   "imports": ["path"],
   "classes": []
}
\end{lstlisting}

\begin{lstlisting}[caption={classes output}, frame=single]
"classes": [
     {
        "type": "interface",
        "javaDoc": null,
        "visibility": "public",
        "name": "className",
        "extend": "superClass",
        "implement": [
            "interfaceName"
        ],
        "body": {
            "variable": [],
            "method": []
        }
    }
]
\end{lstlisting}

\begin{lstlisting}[caption={variable output}, frame=single]
"variable": [
    {
        "type": "variable",
        "javaDoc": null,
        "name": "varName",
        "visibility": "public",
        "modifier": [
            "static",
            "final"
        ],
        "array": false,
        "generic": null,
        "dataType": "int",
        "value": "42"
    }
]
\end{lstlisting}

\begin{lstlisting}[caption={method output}, frame=single]
"method": [
    {
        "type": "method",
        "javaDoc": {},
        "name": "methodName",
        "visibility": "public",
        "modifier": [],
        "generic": null,
        "array": true,
        "dataType": "String",
        "parameter": [
            {
                "type": "parameter",
                "modifier": ["static"],
                "generic": "T",
                "array": false,
                "dataType": "Object",
                "name": "paramterName"
            }
        ],
        "body": "methodBody"
    }
]
\end{lstlisting}

\begin{lstlisting}[caption={JavaDoc output}, frame=single]
"javaDoc": {
     "since": [
        {
           "tag": "since",
           "description": "desc"
        }
     ],
     "throws": [
        {
           "tag": "throws",
           "classname": "className",
           "description": "desc"
        }
     ],
     "exception": [
        {
           "tag": "exception",
           "classname": "className",
           "description": "desc"
        }
     ],
     "param": [
        {
           "tag": "param",
           "name": "paramName",
           "description": "desc"
        }
     ],
     "return": [
        {
           "tag": "return",
           "description": "desc"
        }
     ],
     "see": [
        {
           "tag": "see",
           "description": "desc"
        }
     ]
}
\end{lstlisting}

\subsubsection{Class diagram generation}
After parsing the Java source code the new data structure can be used to build a class diagram, which visualize the logical structure of its program. The process which builds the class diagram is subdivided into 3 parts. In the first step each class with all selected info - like the name, its variables and operations - will be created. If two classes with the same name exist, the name of the second class will be renamed. In this case each relation which has a reference on its class name could not be created anymore. During the first step any information which is needed for generalizations or the relations of provided interfaces will be stored. So it is not necessary to read the parser output twice. With the help of the stored information each generalization and all relations of provided interfaces can be created in step two. The last step needs the interpretation of each created class. To generate associations or the relations of required interfaces, each attribute of each class has to be analyzed. If an attribute has a data type of an existing class, it's a candidate for an association. In this case this class will be analyzed, too, to figure out whether the association has bidirectional navigation.

\subsection{Forward engineering}
To generate the source code from an existing class diagram, it’s essential to analyze each available class and connector, like generalizations or associations. The analyzing process will be handled from the classes themselves. So a class contains all necessary information and can handle it without an additional effort. Operations, parameter, attributes and classes own a method called \textit{getJSON()} that creates an output which is identical to the parser output \ref{json} and will be used to generate the source code. Furthermore it gets the relations between classes, so an additional process isn’t necessary. On getting each declared attribute, associations of the two classes and each required interface will be collected and set as attribute. Moreover if an interface extends another interface it will set as superclass and declare with the extend keyword, in the other case if a class provides an interface the implements keyword will be used. The following sections explain each available relation and their implementation. 

\subsubsection{Generalization}
\label{generalization}
If a class inherits from another class the subclass has to signalize the relation with the keyword “extends” in its declaration. In addition each operation and attribute which exists in the superclass doesn’t need to be implemented into the subclass twice. If the user defines an operation which has the same name and parameter list of another one in the superclass, the superclass operation will be overwritten. To execute the method of the superclass Java contains the “super” keyword which is a reference on its superclass.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{images/example_generalization.png}
\end{figure}

The class diagram shows the superclass “UIObject” and two subclasses which inherit from it. Moreover the class “Dialog” overrides the operation “setUIType” and implements some other methods.

\lstset{
	language=Java, 
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1
}

\begin{lstlisting}[caption={The following code snippet shows the result of the code generation.}, frame=single]
public class UIObject {
	private String uitype;
	private String htmlId;
	
	public void setUIType(String type) {}
}

public class Button extends UIObject {
	public void onClick() {}
}

public class Dialog extends UIObject {
	public void setUIType(String type) {}

	public void open() {}

	public void close() {}
}
\end{lstlisting}

\subsubsection{Binary association}
A binary association specifies a semantic relationship between two classes. So each class knew about the other one and is able to interact or communicate with it. An association provides a collection of properties, which are important to interpret for the code generation. First of all the multiplicity of a class defines the frequency of occurrence. If a multiplicity is declared as \lbrack 1..5\rbrack  the class has to declare once and can be declared at most five time. In the source code a multiplicity represents an array if a class can declare more than one time. Otherwise it’s a simple variable. Furthermore the role of a class gives the instance of itself a specific name. So if a role is set, the variable gets the name of it. In addition it's possible to set the visibility of a role. The last necessary association property is the navigation. An arrow visualizes the direction of the navigation and specify in which class the other one will be accessible. The bidirectional navigation allows the navigation in both directions.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{images/example_association.png}
\end{figure}

In this example the dialog implements a button which is called "okButton". In addition it's accessible in the dialog class only, 'cause of the "private" visibility. Moreover the multiplicity of 1 provides that only one button can instantiate.

\begin{lstlisting}[caption={The following code snippet shows the result of the code generation.}, frame=single]
public class Button {
	public void onClick() {}
}

public class Dialog {
	private Button okButton;
	
	public void setUIType(String type) {}

	public void open() {}

	public void close() {}
}
\end{lstlisting}

\subsubsection{Provided interfaces}
Provided interfaces are like generalizations with abstract classes. Each operation will be inherited and has to overwrite in the subclass. The only two differences are the "implements" keyword – instead of the “extends” keyword – which is use for inheritance and the fact that it's possible to implement more than one interface. When using more than one interface, each interface will be separated by a comma, at its declaration. An interface provides abstract methods only, which order a specific realization of the class that inherits from it.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{images/example_provided_interface.png}
\end{figure}



\begin{lstlisting}[caption={The following code snippet shows the result of the code generation.}, frame=single]
public interface File {
	private String name;
	private String path;
	
	public void open(String mode);

	public void close();
}

public class JavaFile implements File {
	public String getSourceCode() {}
	
	public void open(String mode);

	public void close();
}
\end{lstlisting}

\subsubsection{Required interfaces}
A required interface allows the communication between a class and another class which implements an interface. If more than one class inherit from a specific interface it's possible to get access to each of them in the same way. This means that all classes which communicate through that interface are constrained of its operations. So it would throw exceptions if one of those operations is changed. A required interface will be declared as an attribute and can be initialized by any constructor of classes which implement the interface.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{images/example_required_interface.png}
\end{figure}

\begin{lstlisting}[caption={The following code snippet shows the result of the code generation.}, frame=single]
public interface File {
	private String name;
	private String path;
	
	public void open(String mode);

	public void close();
}

public class FileBrowser {	
	private String dialogTitle;
	private File _file;

	public void close() {}
}
\end{lstlisting}

\subsubsection{Extended interfaces}
If an interface will be extended, a generalization \ref{generalization} has to be used. That includes the UML generalization arrow and on the Java side, the use of the “extends” keyword.

\end{document}